
==================== FINAL INTERFACE ====================
2017-10-13 09:10:16.01743014 UTC

interface Monoid-0.1.0.0-8OQYrO08pKgJ5cyLnRejZB:Combine 8002
  interface hash: efe9846ec1da84b2aebd14f981120db8
  ABI hash: f729e8e51907ceb96e96bd3c775d19ec
  export-list hash: d441b552f3fa7f5ffa9b7ec479cf3837
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 05c6dca22f9dd1832b6d5a0e6ea172a8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Combine.combineAssoc
  Combine.Combine{Combine.Combine unCombine}
module dependencies:
package dependencies: QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      template-haskell-2.11.1.0
                      tf-random-0.5@tf-random-0.5-CJZw1ZWS5MOJlR60HqKEZL
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu:Test.QuickCheck 7a1791e2e66f06ce3b95a443f0d4b1ed
import  -/  QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu:Test.QuickCheck.Arbitrary 0e953baf64c505f1557b2f8788d63173
import  -/  base-4.9.1.0:Data.Semigroup fc55c71ff629dcbd821309c310055959
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fArbitraryCombine ::
    (Test.QuickCheck.Arbitrary.CoArbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary (Combine.Combine a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(U))))><L,U(U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dCoArbitrary :: Test.QuickCheck.Arbitrary.CoArbitrary a)
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (Combine.Combine a b)
                  (Combine.$fArbitraryCombine_$carbitrary
                     @ a
                     @ b
                     $dCoArbitrary
                     $dArbitrary)
                  (Combine.$fArbitraryCombine_$cshrink
                     @ a
                     @ b
                     $dCoArbitrary
                     $dArbitrary) -}
352685d69466fd68018c041793576518
  $fArbitraryCombine1 ::
    (Test.QuickCheck.Arbitrary.CoArbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(U))))><L,1*U(1*U,A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dCoArbitrary :: Test.QuickCheck.Arbitrary.CoArbitrary a)
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Arbitrary.$fArbitrary(->)1
                   @ a
                   @ b
                   $dCoArbitrary
                   $dArbitrary
                   (case eta
                           `cast`
                         (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                    case System.Random.TF.Gen.$wtfGenSplit
                           ww1
                           ww2
                           ww3
                           ww4 of ww7 { (#,#) ww8 ww9 ->
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } })
                   eta1) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fArbitraryCombine_$carbitrary ::
    (Test.QuickCheck.Arbitrary.CoArbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Gen.Gen (Combine.Combine a b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(U))))><L,1*U(1*U,A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Combine.$fArbitraryCombine1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Test.QuickCheck.Arbitrary.CoArbitrary a>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary b>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               (Combine.N:Combine[0] <a>_N <b>_N))) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fArbitraryCombine_$cshrink ::
    (Test.QuickCheck.Arbitrary.CoArbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Combine.Combine a b -> [Combine.Combine a b]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   ($dCoArbitrary :: Test.QuickCheck.Arbitrary.CoArbitrary a)
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ds1 :: Combine.Combine a b) ->
                 GHC.Types.[] @ (Combine.Combine a b)) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fSemigroupCombine ::
    Data.Semigroup.Semigroup b =>
    Data.Semigroup.Semigroup (Combine.Combine a b)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b
                      @ a
                      ($dSemigroup :: Data.Semigroup.Semigroup b).
                  @ (Combine.Combine a b)
                  (Combine.$fSemigroupCombine_$c<> @ b @ a $dSemigroup)
                  (Combine.$fSemigroupCombine_$csconcat @ b @ a $dSemigroup)
                  (Combine.$fSemigroupCombine_$cstimes @ b @ a $dSemigroup) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fSemigroupCombine1 ::
    Data.Semigroup.Semigroup b =>
    Combine.Combine a b -> Combine.Combine a b -> a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ b
                   @ a
                   ($dSemigroup :: Data.Semigroup.Semigroup b)
                   (ds :: Combine.Combine a b)
                   (ds1 :: Combine.Combine a b)
                   (x :: a) ->
                 Data.Semigroup.<>
                   @ b
                   $dSemigroup
                   (ds `cast` (Combine.N:Combine[0] <a>_N <b>_N) x)
                   (ds1 `cast` (Combine.N:Combine[0] <a>_N <b>_N) x)) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fSemigroupCombine_$c<> ::
    Data.Semigroup.Semigroup b =>
    Combine.Combine a b -> Combine.Combine a b -> Combine.Combine a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Combine.$fSemigroupCombine1
                  `cast`
                (forall (b :: <*>_N) (a :: <*>_N).
                 <Data.Semigroup.Semigroup b>_R
                 ->_R <Combine.Combine a b>_R
                 ->_R <Combine.Combine a b>_R
                 ->_R Sym (Combine.N:Combine[0]) <a>_N <b>_N) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fSemigroupCombine_$csconcat ::
    Data.Semigroup.Semigroup b =>
    Data.List.NonEmpty.NonEmpty (Combine.Combine a b)
    -> Combine.Combine a b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   @ a
                   (w :: Data.Semigroup.Semigroup b)
                   (w1 :: Data.List.NonEmpty.NonEmpty (Combine.Combine a b)) ->
                 case w1 of ww { Data.List.NonEmpty.:| ww1 ww2 ->
                 Combine.$w$csconcat @ b @ a w ww1 ww2 }) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fSemigroupCombine_$cstimes ::
    Data.Semigroup.Semigroup b =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Combine.Combine a b -> Combine.Combine a b
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><S(SLLLLLLLL),U(U,U,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U> -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fShowCombine :: GHC.Show.Show (Combine.Combine a b)
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b.
                  @ (Combine.Combine a b)
                  (Combine.$fShowCombine_$cshowsPrec @ a @ b)
                  (Combine.$fShowCombine_$cshow @ a @ b)
                  (Combine.$fShowCombine_$cshowList @ a @ b) -}
24b25e4cc2ab53e1441d0f18f2d85347
  $fShowCombine1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Combine { unCombine = <function> }"#) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fShowCombine_$cshow :: Combine.Combine a b -> GHC.Base.String
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: Combine.Combine a b) ->
                 Combine.$fShowCombine1) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fShowCombine_$cshowList :: [Combine.Combine a b] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ls :: [Combine.Combine a b]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Combine.Combine a b)
                   (\ (x :: Combine.Combine a b) (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.augment
                      @ GHC.Types.Char
                      (\ @ b1
                         (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr @ GHC.Types.Char @ b1 c n Combine.$fShowCombine1)
                      s1)
                   ls
                   s) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $fShowCombine_$cshowsPrec ::
    GHC.Types.Int -> Combine.Combine a b -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><L,A><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (ds :: GHC.Types.Int)
                   (x :: Combine.Combine a b)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b1
                      (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b1 c n Combine.$fShowCombine1)
                   s) -}
152259cfe79630169e924ee1504c7bfc
  $tc'Combine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14231154377677536538##
                   13202268102192984086##
                   Combine.$trModule
                   Combine.$tc'Combine1) -}
a7661f17d91e5c6a5ae9c15b1d574033
  $tc'Combine1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Combine"#) -}
fd98f7d190a8834b792eae52eb64f878
  $tcCombine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2012982374155535369##
                   12885066833932435977##
                   Combine.$trModule
                   Combine.$trModule1) -}
fe9378b06603b31b1e4079da8d0bbe83
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Combine.$trModule2
                   Combine.$trModule1) -}
fe45a940b059349e8fe68458da56a5fd
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Combine"#) -}
bb84d5ab1041bdec7558af07c3197275
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Monoid-0.1.0.0-8OQYrO08pKgJ5cyLnRejZB"#) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  $w$csconcat ::
    Data.Semigroup.Semigroup b =>
    Combine.Combine a b -> [Combine.Combine a b] -> Combine.Combine a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ b
                   @ a
                   (w :: Data.Semigroup.Semigroup b)
                   (ww :: Combine.Combine a b)
                   (ww1 :: [Combine.Combine a b]) ->
                 letrec {
                   go :: Combine.Combine a b
                         -> [Combine.Combine a b] -> Combine.Combine a b
                     {- Arity: 2, Strictness: <L,U><S,1*U> -}
                   = \ (b1 :: Combine.Combine a b) (ds1 :: [Combine.Combine a b]) ->
                     case ds1 of wild1 {
                       [] -> b1
                       : c cs
                       -> let {
                            ds :: Combine.Combine a b = go c cs
                          } in
                          (\ (x :: a) ->
                           Data.Semigroup.<>
                             @ b
                             w
                             (b1 `cast` (Combine.N:Combine[0] <a>_N <b>_N) x)
                             (ds `cast` (Combine.N:Combine[0] <a>_N <b>_N) x))
                            `cast`
                          (Sym (Combine.N:Combine[0]) <a>_N <b>_N) }
                 } in
                 go ww ww1) -}
4d3a4a9dfb2687fcbfbfd663f8f483ff
  newtype Combine a b = Combine {unCombine :: a -> b}
f684e03006e400e758dab2e34a5e70e4
  combineAssoc ::
    Combine.Combine GHC.Types.Int GHC.Base.String
    -> Combine.Combine GHC.Types.Int GHC.Base.String
    -> Combine.Combine GHC.Types.Int GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(S),C(U)><L,C(U)><L,C(U)><L,U>,
     Unfolding: (\ (a :: Combine.Combine GHC.Types.Int GHC.Base.String)
                   (b :: Combine.Combine GHC.Types.Int GHC.Base.String)
                   (c :: Combine.Combine GHC.Types.Int GHC.Base.String)
                   (d :: GHC.Types.Int) ->
                 GHC.Base.eqString
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (a `cast`
                       (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                         d)
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (b `cast`
                          (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                            d)
                         (c `cast`
                          (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                            d)))
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (a `cast`
                       (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                         d)
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (b `cast`
                          (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                            d)
                         (c `cast`
                          (Combine.N:Combine[0] <GHC.Types.Int>_N <[GHC.Types.Char]>_N)
                            d)))) -}
98852bf4ed0223938756344d67644e41
  unCombine :: Combine.Combine a b -> a -> b
  RecSel Left Combine.Combine
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Combine.unCombine1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Combine.Combine a b>_R ->_R Combine.N:Combine[0] <a>_N <b>_N) -}
5790cd880841dc0e7bf5503d7e6b2a51
  unCombine1 :: Combine.Combine a b -> Combine.Combine a b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: Combine.Combine a b) -> ds) -}
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Combine.Combine]
  = Combine.$fArbitraryCombine
instance [safe] Data.Semigroup.Semigroup [Combine.Combine]
  = Combine.$fSemigroupCombine
instance [safe] GHC.Show.Show [Combine.Combine]
  = Combine.$fShowCombine
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

